// package wacc

// import org.scalatest.flatspec.AnyFlatSpec
// import org.scalatest.matchers.should.Matchers._
// import wacc.IR._
// import wacc.Parser._
// import wacc.Types._
// import scala.collection.mutable.ListBuffer
// import wacc.Analyser.checkProgram
// import org.scalatest.BeforeAndAfterEach
// import org.scalatest.BeforeAndAfterAll

// class IRConversionUnitTests extends AnyFlatSpec with BeforeAndAfterEach with BeforeAndAfterAll {
  
//   val c = Analyser.getClass.getDeclaredConstructor()

//   override def beforeAll() = c.setAccessible(true)

//   override def beforeEach() = c.newInstance()

//   "IR Conversion" should "generate the correct IR for an AST for a basic declaration" in {
//       val program = parseAsProgram("begin int x = 3 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic reassignment" in {
//       val program = parseAsProgram("begin int x = 3; x = 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a simple addition" in {
//       val program = parseAsProgram("begin int x = 3 + 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a complex addition" in {
//       val program = parseAsProgram("begin int x = (3 + 4) + (5 + 6) end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(6)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with string literals" in {
//       val program = parseAsProgram("begin print \"Hello\" end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Data(LabelRef(".L.str0"),"Hello"), Instr(LDR,Some(R8),Some(LabelRef(".L.str0")),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAStringType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with int literals" in {
//       val program = parseAsProgram("begin print 3 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAIntType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with bool literals" in {
//       val program = parseAsProgram("begin print true end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(1)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SABoolType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with char literals" in {
//       val program = parseAsProgram("begin print 'a' end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(97)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SACharType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with binary operator application" in {
//       val program = parseAsProgram("begin print 3 + 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAIntType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with variable references" in {
//       val program = parseAsProgram("begin int x = 3; print x end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAIntType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for print statements with variable references and binary operator applications" in {
//       val program = parseAsProgram("begin int x = 3; print x + 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAIntType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for two print statements with different string literals" in {
//       val program = parseAsProgram("begin print \"Hello\"; print \"World\" end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Data(LabelRef(".L.str0"),"Hello"), Instr(LDR,Some(R8),Some(LabelRef(".L.str0")),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAStringType),None,None,None,AL), Data(LabelRef(".L.str1"),"World"), Instr(LDR,Some(R8),Some(LabelRef(".L.str1")),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAStringType),None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for reassignment" in {
//       val program = parseAsProgram("begin int x = 3; x = 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a simple multiplication" in {
//       val program = parseAsProgram("begin int x = 3 * 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(SMULL,Some(JoinedRegister(R8,R9)),Some(JoinedRegister(R8,R9)),None,AL), Instr(CMP,Some(R9),Some(ShiftedRegister(R8,Shift(ASR,31))),None,AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,NE), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a simple division" in {
//       val program = parseAsProgram("begin int x = 3 / 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(DIV,Some(R8),Some(R8),Some(R9),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a complex addition and multiplication" in {
//       val program = parseAsProgram("begin int x = (3 + 4) * (5 + 6) end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(6)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(SMULL,Some(JoinedRegister(R8,R9)),Some(JoinedRegister(R8,R9)),None,AL), Instr(CMP,Some(R9),Some(ShiftedRegister(R8,Shift(ASR,31))),None,AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,NE), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a simple new pair declaration" in {
//       val program = parseAsProgram("begin pair(int, int) x = newpair(3, 4) end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a reassignment to a new pair" in {
//       val program = parseAsProgram("begin pair(int, int) x = newpair(3, 4); x = newpair(4, 5) end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for an array literal declaration" in {
//       val program = parseAsProgram("begin int[] x = [1, 2, 3] end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for an array literal reassignment" in {
//       val program = parseAsProgram("begin int[] x = [1,2,3] ; x[0] = 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a 2D array literal declaration" in {
//       val program = parseAsProgram("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(16)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-12)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic 2D array literal reassignment" in {
//       val program = parseAsProgram("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] ; d3[0] = d2 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(16)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-12)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-12)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a 2D array literal reassignment" in {
//       val program = parseAsProgram("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] ; d3[0][1] = 4 end")
//       val (_, symbolTable, _) = checkProgram(program)
//       val (instructions, _) = buildIR(program, symbolTable)
//       instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(16)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(5)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(2)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-12)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic if statement" in {
//     val program = parseAsProgram("begin if true then skip else skip fi end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(1)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(Imm(1)),None,AL), Instr(B,Some(LabelRef(".L0")),None,None,NE), Instr(B,Some(LabelRef(".L1")),None,None,AL), Label(".L0"), Label(".L1"), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a nested if statement" in {
//     val program = parseAsProgram("begin if true then if true then skip else skip fi else skip fi end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(1)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(Imm(1)),None,AL), Instr(B,Some(LabelRef(".L0")),None,None,NE), Instr(MOV,Some(R8),Some(Imm(1)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(Imm(1)),None,AL), Instr(B,Some(LabelRef(".L2")),None,None,NE), Instr(B,Some(LabelRef(".L3")),None,None,AL), Label(".L2"), Label(".L3"), Instr(B,Some(LabelRef(".L1")),None,None,AL), Label(".L0"), Label(".L1"), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic while statement" in {
//     val program = parseAsProgram("begin while false do skip done end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Label(".L0"), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(Imm(1)),None,AL), Instr(B,Some(LabelRef(".L1")),None,None,NE), Instr(B,Some(LabelRef(".L0")),None,None,AL), Label(".L1"), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic read statement" in {
//     val program = parseAsProgram("begin int x = 0 ; read x end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(MOV,Some(R1),Some(Imm(0)),None,AL), Instr(ADD,Some(R1),Some(R1),Some(Imm(4)),AL), Instr(BL,Some(LabelRef("read")),None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic free statement for a pair" in {
//     val program = parseAsProgram("begin pair(int,int) x = newpair(1,1) ; free x end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("pair_free")),None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic free statement for an array" in {
//     val program = parseAsProgram("begin int[] x = [1] ; free x end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(1)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_free")),None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic function declaration and call" in {
//     val program = parseAsProgram("begin int f() is return 0 end int x = call f() ; println x end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Label("wacc_f"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg, Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(BL,Some(LabelRef("wacc_f")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(PRINT(SAIntType),None,None,None,AL), Instr(PRINTLN,None,None,None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a nested function declaration and call" in {
//     val program = parseAsProgram("begin int rec(int x) is if x == 0 then skip else int y = call rec(x - 1) fi ; return 42 end int x = 0 ; x = call rec(8) end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Label("wacc_rec"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(LDR,Some(R8),Some(AddrReg(FP,4)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(R9),None,AL), Instr(MOV,Some(R8),Some(Imm(1)),None,EQ), Instr(MOV,Some(R8),Some(Imm(0)),None,NE), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(CMP,Some(R8),Some(Imm(1)),None,AL), Instr(B,Some(LabelRef(".L0")),None,None,NE), Instr(B,Some(LabelRef(".L1")),None,None,AL), Label(".L0"), Instr(LDR,Some(R8),Some(AddrReg(FP,4)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(SUBS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("wacc_rec")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Label(".L1"), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(42)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg, Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(8)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(8)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("wacc_rec")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic pair elem access" in {
//     val program = parseAsProgram("begin pair(int,int) p = newpair(1,2) ; int x = fst p end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(12)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("pair_fst")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a complex pair elem access" in {
//     val program = parseAsProgram("begin pair(int,int) p = newpair(1,2) ; pair(int,int)[] ps = [p] ; int x = fst ps[0] end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(16)),AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("pair_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(1)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("pair_fst")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(16)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a basic array elem access" in {
//     val program = parseAsProgram("begin int[] xs = [1,2,3] ; int x = xs[0] end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(12)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }

//   "IR Conversion" should "generate the correct IR for an AST for a complex array elem access" in {
//     val program = parseAsProgram("begin int[] d1 = [1,2,3] ; d1[2] = 4 ; int[][] d2 = [d1] ; d2[0][1 + 0] = 3 end")
//     val (_, symbolTable, _) = checkProgram(program)
//     val (instructions, _) = buildIR(program, symbolTable)
//     instructions should be (ListBuffer(Global("main"), Label("main"), Instr(PUSH,Some(LR),None,None,AL), Instr(PUSH,Some(FP),None,None,AL), Instr(ADD,Some(FP),Some(SP),Some(Imm(4)),AL), Instr(SUB,Some(SP),Some(SP),Some(Imm(12)),AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(3)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(4)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(8)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(2)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(4)),None,AL), Instr(MOV,Some(R1),Some(Imm(1)),None,AL), Instr(LDR,Some(R8),Some(AddrReg(FP,-8)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(BL,Some(LabelRef("array_literal_create")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(3)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(SUB,Some(R0),Some(FP),Some(Imm(12)),AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(ADD,Some(R8),Some(R8),Some(Imm(1)),AL), Instr(PUSH,Some(R8),None,None,AL), Instr(MOV,Some(R8),Some(Imm(0)),None,AL), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R9),None,None,AL), Instr(POP,Some(R8),None,None,AL), Instr(ADDS,Some(R8),Some(R8),Some(R9),AL), Instr(BL,Some(LabelRef("error_arithmetic_overflow")),None,None,VS), Instr(PUSH,Some(R8),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(LDR,Some(R0),Some(AddrReg(R0,0)),None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(BL,Some(LabelRef("array_access")),None,None,AL), Instr(PUSH,Some(R0),None,None,AL), Instr(POP,Some(R1),None,None,AL), Instr(POP,Some(R0),None,None,AL), Instr(STR,Some(R0),Some(AddrReg(R1,0)),None,AL), Instr(MOV,Some(R0),Some(Imm(0)),None,AL), Instr(SUB,Some(SP),Some(FP),Some(Imm(4)),AL), Instr(POP,Some(FP),None,None,AL), Instr(POP,Some(PC),None,None,AL), Ltorg))
//   }
// }
