package wacc

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers._
import wacc.IR._
import wacc.Parser._
import wacc.Types._
import scala.collection.mutable.ListBuffer
import wacc.Analyser.checkProgram
import org.scalatest.BeforeAndAfterEach
import org.scalatest.BeforeAndAfterAll
import scala.collection.mutable.Map
import wacc.AST.Type

class IRConversionUnitTests extends AnyFlatSpec with BeforeAndAfterEach with BeforeAndAfterAll {
  
  // Required to reset Map, as it is persistent between tests otherwise
  val analyserInstance = Analyser.getClass.getDeclaredConstructor()

  override protected def beforeAll() = analyserInstance.setAccessible(true)

  override protected  def beforeEach() = analyserInstance.newInstance()

  override protected def afterAll() = analyserInstance.setAccessible(false)

  def buildInstructions(input: String) = {
    val program = parseAsProgram(input)
    implicit val funcToLibMap: Map [String, String] = Map()
    implicit val libToFuncMap: Map[String, List[(String, List[(Type, List[Type])])]] = Map()
    val (_, symbolTable, _, newProgram) = checkProgram(program)
    val instructions = buildIR(newProgram, symbolTable)
    instructions
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic declaration" in {
      assert(buildInstructions("begin int x = 3 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic reassignment" in {
      assert(buildInstructions("begin int x = 3; x = 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a simple addition" in {
      assert(buildInstructions("begin int x = 3 + 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a complex addition" in {
      assert(buildInstructions("begin int x = (3 + 4) + (5 + 6) end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(6)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with string literals" in {
      assert(buildInstructions("begin print \"Hello\" end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Data(LabelRef(".L.str0"),"Hello"), Instr(LDR,R8,LabelRef(".L.str0")), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAStringType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with int literals" in {
      assert(buildInstructions("begin print 3 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAIntType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with bool literals" in {
      assert(buildInstructions("begin print true end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SABoolType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with char literals" in {
      assert(buildInstructions("begin print 'a' end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(97)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SACharType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with binary operator application" in {
      assert(buildInstructions("begin print 3 + 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAIntType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with variable references" in {
      assert(buildInstructions("begin int x = 3; print x end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAIntType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for print statements with variable references and binary operator applications" in {
      assert(buildInstructions("begin int x = 3; print x + 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAIntType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString())
  }

  "IR Conversion" should "generate the correct IR for two print statements with different string literals" in {
      assert(buildInstructions("begin print \"Hello\"; print \"World\" end").toString() == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Data(LabelRef(".L.str0"),"Hello"), Instr(LDR,R8,LabelRef(".L.str0")), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAStringType)), Data(LabelRef(".L.str1"),"World"), Instr(LDR,R8,LabelRef(".L.str1")), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAStringType)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for reassignment" in {
      assert(buildInstructions("begin int x = 3; x = 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a simple multiplication" in {
      assert(buildInstructions("begin int x = 3 * 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(SMULL,JoinedRegister(R8,R9),JoinedRegister(R8,R9)), Instr(CMP,R9,ShiftedRegister(R8,Shift(ASR,31))), Instr(BL,BranchLabel("error_arithmetic_overflow"),NE), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a simple division" in {
      assert(buildInstructions("begin int x = 3 / 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(MOV,R0,R8), Instr(MOV,R1,R9), Instr(DIV), Instr(MOV,R8,R0), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a complex addition and multiplication" in {
      assert(buildInstructions("begin int x = (3 + 4) * (5 + 6) end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(6)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(SMULL,JoinedRegister(R8,R9),JoinedRegister(R8,R9)), Instr(CMP,R9,ShiftedRegister(R8,Shift(ASR,31))), Instr(BL,BranchLabel("error_arithmetic_overflow"),NE), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a simple new pair declaration" in {
      assert(buildInstructions("begin pair(int, int) x = newpair(3, 4) end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a reassignment to a new pair" in {
      assert(buildInstructions("begin pair(int, int) x = newpair(3, 4); x = newpair(4, 5) end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for an array literal declaration" in {
      assert(buildInstructions("begin int[] x = [1, 2, 3] end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for an array literal reassignment" in {
      assert(buildInstructions("begin int[] x = [1,2,3] ; x[0] = 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a 2D array literal declaration" in {
      assert(buildInstructions("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(16)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(LDR,R8,AddrReg(FP,-12)), Instr(PUSH,RegisterList(List(R8))), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic 2D array literal reassignment" in {
      assert(buildInstructions("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] ; d3[0] = d2 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(16)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(LDR,R8,AddrReg(FP,-12)), Instr(PUSH,RegisterList(List(R8))), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-12)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a 2D array literal reassignment" in {
      assert(buildInstructions("begin int[] d1 = [1, 2, 3] ; int[] d2 = [4, 5] ; int[][] d3 = [d1, d2] ; d3[0][1] = 4 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(16)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(5)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(2)), Instr(LDR,R8,AddrReg(FP,-12)), Instr(PUSH,RegisterList(List(R8))), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic if statement" in {
      assert(buildInstructions("begin if true then skip else skip fi end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,Imm(1)), Instr(B,BranchLabel(".L0"),NE), Instr(B,BranchLabel(".L1")), Label(".L0"), Label(".L1"), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a nested if statement" in {
      assert(buildInstructions("begin if true then if true then skip else skip fi else skip fi end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,Imm(1)), Instr(B,BranchLabel(".L0"),NE), Instr(MOV,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,Imm(1)), Instr(B,BranchLabel(".L2"),NE), Instr(B,BranchLabel(".L3")), Label(".L2"), Label(".L3"), Instr(B,BranchLabel(".L1")), Label(".L0"), Label(".L1"), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic while statement" in {
      assert(buildInstructions("begin while false do skip done end").toString() == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Label(".L0"), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,Imm(1)), Instr(B,BranchLabel(".L1"),NE), Instr(B,BranchLabel(".L0")), Label(".L1"), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic read statement" in {
      assert(buildInstructions("begin int x = 0 ; read x end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(MOV,R1,Imm(0)), Instr(ADD,R1,R1,Imm(4)), Instr(BL,BranchLabel("read")), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic free statement for a pair" in {
      assert(buildInstructions("begin pair(int,int) x = newpair(1,1) ; free x end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("pair_free")), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic free statement for an array" in {
      assert(buildInstructions("begin int[] x = [1] ; free x end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(1)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_free")), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic function declaration and call" in {
      assert(buildInstructions("begin int f() is return 0 end int x = call f() ; println x end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Label("f_0__0"), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(PRINT(SAIntType)), Instr(PRINTLN), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a nested function declaration and call" in {
      assert(buildInstructions("begin int rec(int x) is if x == 0 then skip else int y = call rec(x - 1) fi ; return 42 end int x = 0 ; x = call rec(8) end").toString == (ListBuffer(Label("wacc_rec_0"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(LDR,R8,AddrReg(FP,4)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,R9), Instr(MOV,R8,Imm(1),EQ), Instr(MOV,R8,Imm(0),NE), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R8))), Instr(CMP,R8,Imm(1)), Instr(B,BranchLabel(".L0"),NE), Instr(B,BranchLabel(".L1")), Label(".L0"), Instr(LDR,R8,AddrReg(FP,4)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(SUBS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("wacc_rec_0")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Label(".L1"), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(42)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R0))), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg, Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(8)), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("wacc_rec_0")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic pair elem access" in {
      assert(buildInstructions("begin pair(int,int) p = newpair(1,2) ; int x = fst p end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(12)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("pair_fst")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a complex pair elem access" in {
      assert(buildInstructions("begin pair(int,int) p = newpair(1,2) ; pair(int,int)[] ps = [p] ; int x = fst ps[0] end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(16)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("pair_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(1)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("pair_fst")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(16)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a basic array elem access" in {
      assert(buildInstructions("begin int[] xs = [1,2,3] ; int x = xs[0] end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(12)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }

  "IR Conversion" should "generate the correct IR for an AST for a complex array elem access" in {
      assert(buildInstructions("begin int[] d1 = [1,2,3] ; d1[2] = 4 ; int[][] d2 = [d1] ; d2[0][1 + 0] = 3 end").toString == (ListBuffer(Global("main"), Label("main"), Instr(PUSH,RegisterList(List(LR))), Instr(PUSH,RegisterList(List(FP))), Instr(ADD,FP,SP,Imm(4)), Instr(SUB,SP,SP,Imm(12)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(3)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(4)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(8)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(2)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(4)), Instr(MOV,R1,Imm(1)), Instr(LDR,R8,AddrReg(FP,-8)), Instr(PUSH,RegisterList(List(R8))), Instr(BL,BranchLabel("array_literal_create")), Instr(PUSH,RegisterList(List(R0))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(3)), Instr(PUSH,RegisterList(List(R8))), Instr(SUB,R0,FP,Imm(12)), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(MOV,R8,Imm(0)), Instr(ADD,R8,R8,Imm(1)), Instr(PUSH,RegisterList(List(R8))), Instr(MOV,R8,Imm(0)), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R9))), Instr(POP,RegisterList(List(R8))), Instr(ADDS,R8,R8,R9), Instr(BL,BranchLabel("error_arithmetic_overflow"),VS), Instr(PUSH,RegisterList(List(R8))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(LDR,R0,AddrReg(R0,0)), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R0))), Instr(BL,BranchLabel("array_access")), Instr(PUSH,RegisterList(List(R0))), Instr(POP,RegisterList(List(R1))), Instr(POP,RegisterList(List(R0))), Instr(STR,R0,AddrReg(R1,0)), Instr(MOV,R0,Imm(0)), Instr(SUB,SP,FP,Imm(4)), Instr(POP,RegisterList(List(FP))), Instr(POP,RegisterList(List(PC))), Ltorg)).toString)
  }
}
